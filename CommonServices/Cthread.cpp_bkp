//
//  Cthread.cpp
//  ThreadProgramming
//
//  Created by Vivek Yadav on 12/4/18.
//  Copyright Â© 2018 Vivek Yadav. All rights reserved.
//

#include "Cthread.h"
#include <iostream>
#include "Ctask.h"
#include <pthread.h>
#include <unistd.h>
#include <errno.h>

using namespace std;

Cthread::Cthread()
{
    cout << "Entering Cthread constructor" << endl;
    mThreadId = 0;
    cout << "Exiting Cthread constructor" << endl;
}

Cthread::~Cthread()
{
    cout << "Entering Cthread destructor " << endl;
    unsigned int lCount = 0;
    unsigned int lThreadCount = mThreadId;
    for( ; lCount < lThreadCount; ++lCount)
    {
        threadContext_t *lThreadContext_p = mThreadContext_p[lCount];
        delete (lThreadContext_p->task_p);
        lThreadContext_p->task_p = nullptr;
        free(lThreadContext_p);
        mThreadContext_p[lCount] = nullptr;
    }

    mThreadId = 0;
    cout << "Exiting Cthread destructor " << endl;
}

unsigned int Cthread::addThread(Ctask* pTask)
{
    cout << "Entering Cthread::addThread" << endl;
    cout << "Cthread::addThread : " << sizeof(threadContext_t) << " Task name is : " << pTask->getTaskName()<< endl;
    this->printData();
    cout << "\n===== mThreadId: " << mThreadId << "\n" << endl;
    threadContext_t *lThreadContext_p = (threadContext_t *)malloc(sizeof(threadContext_t));
    
    if (lThreadContext_p ==  NULL)
    {
        cerr << "Malloc failure : threadContext_p" << endl;
        return -1;
    }
    lThreadContext_p->task_p = pTask;
    cout << "\n***====*** lThreadContext_p: " << lThreadContext_p << "\n" << endl;
    mMutex.lockMutex();
    lThreadContext_p->threadId = mThreadId;
    mThreadContext_p[mThreadId++] = lThreadContext_p;
    mMutex.unLockMutex();
    this->printData();
    cout << "\n****** mThreadId: " << mThreadId << "\n" << endl;
    cout << "Exiting Cthread::addThread" << endl;
    return lThreadContext_p->threadId;
}

void Cthread::startThread(unsigned int threadId)
{
    cout << "Entering Cthread::startThread" << endl;
    unsigned int lThreadId = pthread_create(&(mThreadContext_p[threadId]->mThreadStruct), NULL, Cthread::threadCallback, (void*)(mThreadContext_p[threadId]->task_p));
    if (lThreadId != 0)
    {
        cerr << "pthread_create failure : " <<  endl;
        return;
    }
    cout << "Exiting Cthread::startThread" << endl;
}

void Cthread::stopThread(unsigned int threadId)
{
    cout << "Entering Cthread::stopThread" << endl;
    mMutex.lockMutex();
    mThreadContext_p[threadId]->task_p->cleanup();
    mMutex.unLockMutex();
    cout << "Exiting Cthread::stopThread" << endl;
}

void* Cthread::threadCallback(void *data)
{
    cout << "Entering Cthread::threadCallback" << endl;
    Ctask *task_p = (Ctask*) data;
    task_p->run();
    cout << "Exiting Cthread::threadCallback" << endl;
    return nullptr;
}

void Cthread::join()
{
    cout << "Entering Cthread::join" << endl;
    void *ret = nullptr;
    cout << "Total number of active threads : " << mThreadId << endl;
    for( unsigned int lCount = 0; lCount < mThreadId; lCount++)
    {
        threadContext_t*    lThreadContext_p    =    mThreadContext_p[lCount];
        cout << "lCount : " << lCount<< endl;
        cout << "Cthread::join--> Thread Name : " << lThreadContext_p->task_p->getTaskName()<< endl;
        if (pthread_join(lThreadContext_p->mThreadStruct, &ret) != 0) {
            std::cerr << "pthread_join() error" << std::endl;
            exit(3);
        }
    }
    cout << "Exiting Cthread::join" << endl;
}

void Cthread::printData()
{
    cout << "Entering Cthread::printData" << endl;
    for( unsigned int lCount = 0; lCount < mThreadId; lCount++)
    {
        threadContext_t*    lThreadContext_p    =    mThreadContext_p[lCount];
        cout << "\n+++++Thread Name : " << lThreadContext_p<< "\n" << endl;
    }
    cout << "Exiting Cthread::printData" << endl;
}
